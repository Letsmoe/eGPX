/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: schemas/v1.1/eGPX.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../google/protobuf/any";
import * as pb_1 from "google-protobuf";
export namespace eGPX {
    export class File extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            version?: string;
            creator?: string;
            metadata?: Metadata;
            wpt?: Waypoint[];
            trk?: Track[];
            rte?: Route[];
            extensions?: Map<string, dependency_1.google.protobuf.Any>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4, 5, 6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("creator" in data && data.creator != undefined) {
                    this.creator = data.creator;
                }
                if ("metadata" in data && data.metadata != undefined) {
                    this.metadata = data.metadata;
                }
                if ("wpt" in data && data.wpt != undefined) {
                    this.wpt = data.wpt;
                }
                if ("trk" in data && data.trk != undefined) {
                    this.trk = data.trk;
                }
                if ("rte" in data && data.rte != undefined) {
                    this.rte = data.rte;
                }
                if ("extensions" in data && data.extensions != undefined) {
                    this.extensions = data.extensions;
                }
            }
            if (!this.extensions)
                this.extensions = new Map();
        }
        get version() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set version(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get creator() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set creator(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get metadata() {
            return pb_1.Message.getWrapperField(this, Metadata, 3) as Metadata;
        }
        set metadata(value: Metadata) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_metadata() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get wpt() {
            return pb_1.Message.getRepeatedWrapperField(this, Waypoint, 4) as Waypoint[];
        }
        set wpt(value: Waypoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get trk() {
            return pb_1.Message.getRepeatedWrapperField(this, Track, 5) as Track[];
        }
        set trk(value: Track[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get rte() {
            return pb_1.Message.getRepeatedWrapperField(this, Route, 6) as Route[];
        }
        set rte(value: Route[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get extensions() {
            return pb_1.Message.getField(this, 7) as any as Map<string, dependency_1.google.protobuf.Any>;
        }
        set extensions(value: Map<string, dependency_1.google.protobuf.Any>) {
            pb_1.Message.setField(this, 7, value as any);
        }
        static fromObject(data: {
            version?: string;
            creator?: string;
            metadata?: ReturnType<typeof Metadata.prototype.toObject>;
            wpt?: ReturnType<typeof Waypoint.prototype.toObject>[];
            trk?: ReturnType<typeof Track.prototype.toObject>[];
            rte?: ReturnType<typeof Route.prototype.toObject>[];
            extensions?: {
                [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            };
        }): File {
            const message = new File({});
            if (data.version != null) {
                message.version = data.version;
            }
            if (data.creator != null) {
                message.creator = data.creator;
            }
            if (data.metadata != null) {
                message.metadata = Metadata.fromObject(data.metadata);
            }
            if (data.wpt != null) {
                message.wpt = data.wpt.map(item => Waypoint.fromObject(item));
            }
            if (data.trk != null) {
                message.trk = data.trk.map(item => Track.fromObject(item));
            }
            if (data.rte != null) {
                message.rte = data.rte.map(item => Route.fromObject(item));
            }
            if (typeof data.extensions == "object") {
                message.extensions = new Map(Object.entries(data.extensions).map(([key, value]) => [key, dependency_1.google.protobuf.Any.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                version?: string;
                creator?: string;
                metadata?: ReturnType<typeof Metadata.prototype.toObject>;
                wpt?: ReturnType<typeof Waypoint.prototype.toObject>[];
                trk?: ReturnType<typeof Track.prototype.toObject>[];
                rte?: ReturnType<typeof Route.prototype.toObject>[];
                extensions?: {
                    [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
                };
            } = {};
            if (this.version != null) {
                data.version = this.version;
            }
            if (this.creator != null) {
                data.creator = this.creator;
            }
            if (this.metadata != null) {
                data.metadata = this.metadata.toObject();
            }
            if (this.wpt != null) {
                data.wpt = this.wpt.map((item: Waypoint) => item.toObject());
            }
            if (this.trk != null) {
                data.trk = this.trk.map((item: Track) => item.toObject());
            }
            if (this.rte != null) {
                data.rte = this.rte.map((item: Route) => item.toObject());
            }
            if (this.extensions != null) {
                data.extensions = (Object.fromEntries)((Array.from)(this.extensions).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.version.length)
                writer.writeString(1, this.version);
            if (this.creator.length)
                writer.writeString(2, this.creator);
            if (this.has_metadata)
                writer.writeMessage(3, this.metadata, () => this.metadata.serialize(writer));
            if (this.wpt.length)
                writer.writeRepeatedMessage(4, this.wpt, (item: Waypoint) => item.serialize(writer));
            if (this.trk.length)
                writer.writeRepeatedMessage(5, this.trk, (item: Track) => item.serialize(writer));
            if (this.rte.length)
                writer.writeRepeatedMessage(6, this.rte, (item: Route) => item.serialize(writer));
            for (const [key, value] of this.extensions) {
                writer.writeMessage(7, this.extensions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): File {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new File();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.version = reader.readString();
                        break;
                    case 2:
                        message.creator = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.metadata, () => message.metadata = Metadata.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.wpt, () => pb_1.Message.addToRepeatedWrapperField(message, 4, Waypoint.deserialize(reader), Waypoint));
                        break;
                    case 5:
                        reader.readMessage(message.trk, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Track.deserialize(reader), Track));
                        break;
                    case 6:
                        reader.readMessage(message.rte, () => pb_1.Message.addToRepeatedWrapperField(message, 6, Route.deserialize(reader), Route));
                        break;
                    case 7:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.extensions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = dependency_1.google.protobuf.Any.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): File {
            return File.deserialize(bytes);
        }
    }
    export class Link extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            href?: string;
            text?: string;
            type?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("href" in data && data.href != undefined) {
                    this.href = data.href;
                }
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
            }
        }
        get href() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set href(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            href?: string;
            text?: string;
            type?: string;
        }): Link {
            const message = new Link({});
            if (data.href != null) {
                message.href = data.href;
            }
            if (data.text != null) {
                message.text = data.text;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            return message;
        }
        toObject() {
            const data: {
                href?: string;
                text?: string;
                type?: string;
            } = {};
            if (this.href != null) {
                data.href = this.href;
            }
            if (this.text != null) {
                data.text = this.text;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.href.length)
                writer.writeString(1, this.href);
            if (this.text.length)
                writer.writeString(2, this.text);
            if (this.type.length)
                writer.writeString(3, this.type);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Link {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Link();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.href = reader.readString();
                        break;
                    case 2:
                        message.text = reader.readString();
                        break;
                    case 3:
                        message.type = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Link {
            return Link.deserialize(bytes);
        }
    }
    export class Waypoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            lat?: number;
            lon?: number;
            ele?: number;
            time?: number;
            magvar?: number;
            geoidheight?: number;
            name?: string;
            cmt?: string;
            desc?: string;
            src?: string;
            link?: Link[];
            sym?: string;
            type?: string;
            fix?: string;
            sat?: number;
            hdop?: number;
            vdop?: number;
            pdop?: number;
            ageofdgpsdata?: number;
            dgpsid?: number;
            extensions?: Map<string, dependency_1.google.protobuf.Any>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [11], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("lat" in data && data.lat != undefined) {
                    this.lat = data.lat;
                }
                if ("lon" in data && data.lon != undefined) {
                    this.lon = data.lon;
                }
                if ("ele" in data && data.ele != undefined) {
                    this.ele = data.ele;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("magvar" in data && data.magvar != undefined) {
                    this.magvar = data.magvar;
                }
                if ("geoidheight" in data && data.geoidheight != undefined) {
                    this.geoidheight = data.geoidheight;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("cmt" in data && data.cmt != undefined) {
                    this.cmt = data.cmt;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("src" in data && data.src != undefined) {
                    this.src = data.src;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("sym" in data && data.sym != undefined) {
                    this.sym = data.sym;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("fix" in data && data.fix != undefined) {
                    this.fix = data.fix;
                }
                if ("sat" in data && data.sat != undefined) {
                    this.sat = data.sat;
                }
                if ("hdop" in data && data.hdop != undefined) {
                    this.hdop = data.hdop;
                }
                if ("vdop" in data && data.vdop != undefined) {
                    this.vdop = data.vdop;
                }
                if ("pdop" in data && data.pdop != undefined) {
                    this.pdop = data.pdop;
                }
                if ("ageofdgpsdata" in data && data.ageofdgpsdata != undefined) {
                    this.ageofdgpsdata = data.ageofdgpsdata;
                }
                if ("dgpsid" in data && data.dgpsid != undefined) {
                    this.dgpsid = data.dgpsid;
                }
                if ("extensions" in data && data.extensions != undefined) {
                    this.extensions = data.extensions;
                }
            }
            if (!this.extensions)
                this.extensions = new Map();
        }
        get lat() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set lat(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get lon() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set lon(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get ele() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set ele(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get magvar() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set magvar(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get geoidheight() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set geoidheight(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get cmt() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set cmt(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 9, value);
        }
        get src() {
            return pb_1.Message.getFieldWithDefault(this, 10, "") as string;
        }
        set src(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        get link() {
            return pb_1.Message.getRepeatedWrapperField(this, Link, 11) as Link[];
        }
        set link(value: Link[]) {
            pb_1.Message.setRepeatedWrapperField(this, 11, value);
        }
        get sym() {
            return pb_1.Message.getFieldWithDefault(this, 12, "") as string;
        }
        set sym(value: string) {
            pb_1.Message.setField(this, 12, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 13, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 13, value);
        }
        get fix() {
            return pb_1.Message.getFieldWithDefault(this, 14, "") as string;
        }
        set fix(value: string) {
            pb_1.Message.setField(this, 14, value);
        }
        get sat() {
            return pb_1.Message.getFieldWithDefault(this, 15, 0) as number;
        }
        set sat(value: number) {
            pb_1.Message.setField(this, 15, value);
        }
        get hdop() {
            return pb_1.Message.getFieldWithDefault(this, 16, 0) as number;
        }
        set hdop(value: number) {
            pb_1.Message.setField(this, 16, value);
        }
        get vdop() {
            return pb_1.Message.getFieldWithDefault(this, 17, 0) as number;
        }
        set vdop(value: number) {
            pb_1.Message.setField(this, 17, value);
        }
        get pdop() {
            return pb_1.Message.getFieldWithDefault(this, 18, 0) as number;
        }
        set pdop(value: number) {
            pb_1.Message.setField(this, 18, value);
        }
        get ageofdgpsdata() {
            return pb_1.Message.getFieldWithDefault(this, 19, 0) as number;
        }
        set ageofdgpsdata(value: number) {
            pb_1.Message.setField(this, 19, value);
        }
        get dgpsid() {
            return pb_1.Message.getFieldWithDefault(this, 20, 0) as number;
        }
        set dgpsid(value: number) {
            pb_1.Message.setField(this, 20, value);
        }
        get extensions() {
            return pb_1.Message.getField(this, 21) as any as Map<string, dependency_1.google.protobuf.Any>;
        }
        set extensions(value: Map<string, dependency_1.google.protobuf.Any>) {
            pb_1.Message.setField(this, 21, value as any);
        }
        static fromObject(data: {
            lat?: number;
            lon?: number;
            ele?: number;
            time?: number;
            magvar?: number;
            geoidheight?: number;
            name?: string;
            cmt?: string;
            desc?: string;
            src?: string;
            link?: ReturnType<typeof Link.prototype.toObject>[];
            sym?: string;
            type?: string;
            fix?: string;
            sat?: number;
            hdop?: number;
            vdop?: number;
            pdop?: number;
            ageofdgpsdata?: number;
            dgpsid?: number;
            extensions?: {
                [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            };
        }): Waypoint {
            const message = new Waypoint({});
            if (data.lat != null) {
                message.lat = data.lat;
            }
            if (data.lon != null) {
                message.lon = data.lon;
            }
            if (data.ele != null) {
                message.ele = data.ele;
            }
            if (data.time != null) {
                message.time = data.time;
            }
            if (data.magvar != null) {
                message.magvar = data.magvar;
            }
            if (data.geoidheight != null) {
                message.geoidheight = data.geoidheight;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.cmt != null) {
                message.cmt = data.cmt;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.src != null) {
                message.src = data.src;
            }
            if (data.link != null) {
                message.link = data.link.map(item => Link.fromObject(item));
            }
            if (data.sym != null) {
                message.sym = data.sym;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.fix != null) {
                message.fix = data.fix;
            }
            if (data.sat != null) {
                message.sat = data.sat;
            }
            if (data.hdop != null) {
                message.hdop = data.hdop;
            }
            if (data.vdop != null) {
                message.vdop = data.vdop;
            }
            if (data.pdop != null) {
                message.pdop = data.pdop;
            }
            if (data.ageofdgpsdata != null) {
                message.ageofdgpsdata = data.ageofdgpsdata;
            }
            if (data.dgpsid != null) {
                message.dgpsid = data.dgpsid;
            }
            if (typeof data.extensions == "object") {
                message.extensions = new Map(Object.entries(data.extensions).map(([key, value]) => [key, dependency_1.google.protobuf.Any.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                lat?: number;
                lon?: number;
                ele?: number;
                time?: number;
                magvar?: number;
                geoidheight?: number;
                name?: string;
                cmt?: string;
                desc?: string;
                src?: string;
                link?: ReturnType<typeof Link.prototype.toObject>[];
                sym?: string;
                type?: string;
                fix?: string;
                sat?: number;
                hdop?: number;
                vdop?: number;
                pdop?: number;
                ageofdgpsdata?: number;
                dgpsid?: number;
                extensions?: {
                    [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
                };
            } = {};
            if (this.lat != null) {
                data.lat = this.lat;
            }
            if (this.lon != null) {
                data.lon = this.lon;
            }
            if (this.ele != null) {
                data.ele = this.ele;
            }
            if (this.time != null) {
                data.time = this.time;
            }
            if (this.magvar != null) {
                data.magvar = this.magvar;
            }
            if (this.geoidheight != null) {
                data.geoidheight = this.geoidheight;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.cmt != null) {
                data.cmt = this.cmt;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.src != null) {
                data.src = this.src;
            }
            if (this.link != null) {
                data.link = this.link.map((item: Link) => item.toObject());
            }
            if (this.sym != null) {
                data.sym = this.sym;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.fix != null) {
                data.fix = this.fix;
            }
            if (this.sat != null) {
                data.sat = this.sat;
            }
            if (this.hdop != null) {
                data.hdop = this.hdop;
            }
            if (this.vdop != null) {
                data.vdop = this.vdop;
            }
            if (this.pdop != null) {
                data.pdop = this.pdop;
            }
            if (this.ageofdgpsdata != null) {
                data.ageofdgpsdata = this.ageofdgpsdata;
            }
            if (this.dgpsid != null) {
                data.dgpsid = this.dgpsid;
            }
            if (this.extensions != null) {
                data.extensions = (Object.fromEntries)((Array.from)(this.extensions).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.lat != 0)
                writer.writeFloat(1, this.lat);
            if (this.lon != 0)
                writer.writeFloat(2, this.lon);
            if (this.ele != 0)
                writer.writeFloat(3, this.ele);
            if (this.time != 0)
                writer.writeInt64(4, this.time);
            if (this.magvar != 0)
                writer.writeFloat(5, this.magvar);
            if (this.geoidheight != 0)
                writer.writeFloat(6, this.geoidheight);
            if (this.name.length)
                writer.writeString(7, this.name);
            if (this.cmt.length)
                writer.writeString(8, this.cmt);
            if (this.desc.length)
                writer.writeString(9, this.desc);
            if (this.src.length)
                writer.writeString(10, this.src);
            if (this.link.length)
                writer.writeRepeatedMessage(11, this.link, (item: Link) => item.serialize(writer));
            if (this.sym.length)
                writer.writeString(12, this.sym);
            if (this.type.length)
                writer.writeString(13, this.type);
            if (this.fix.length)
                writer.writeString(14, this.fix);
            if (this.sat != 0)
                writer.writeInt32(15, this.sat);
            if (this.hdop != 0)
                writer.writeFloat(16, this.hdop);
            if (this.vdop != 0)
                writer.writeFloat(17, this.vdop);
            if (this.pdop != 0)
                writer.writeFloat(18, this.pdop);
            if (this.ageofdgpsdata != 0)
                writer.writeFloat(19, this.ageofdgpsdata);
            if (this.dgpsid != 0)
                writer.writeInt32(20, this.dgpsid);
            for (const [key, value] of this.extensions) {
                writer.writeMessage(21, this.extensions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Waypoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Waypoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.lat = reader.readFloat();
                        break;
                    case 2:
                        message.lon = reader.readFloat();
                        break;
                    case 3:
                        message.ele = reader.readFloat();
                        break;
                    case 4:
                        message.time = reader.readInt64();
                        break;
                    case 5:
                        message.magvar = reader.readFloat();
                        break;
                    case 6:
                        message.geoidheight = reader.readFloat();
                        break;
                    case 7:
                        message.name = reader.readString();
                        break;
                    case 8:
                        message.cmt = reader.readString();
                        break;
                    case 9:
                        message.desc = reader.readString();
                        break;
                    case 10:
                        message.src = reader.readString();
                        break;
                    case 11:
                        reader.readMessage(message.link, () => pb_1.Message.addToRepeatedWrapperField(message, 11, Link.deserialize(reader), Link));
                        break;
                    case 12:
                        message.sym = reader.readString();
                        break;
                    case 13:
                        message.type = reader.readString();
                        break;
                    case 14:
                        message.fix = reader.readString();
                        break;
                    case 15:
                        message.sat = reader.readInt32();
                        break;
                    case 16:
                        message.hdop = reader.readFloat();
                        break;
                    case 17:
                        message.vdop = reader.readFloat();
                        break;
                    case 18:
                        message.pdop = reader.readFloat();
                        break;
                    case 19:
                        message.ageofdgpsdata = reader.readFloat();
                        break;
                    case 20:
                        message.dgpsid = reader.readInt32();
                        break;
                    case 21:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.extensions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = dependency_1.google.protobuf.Any.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Waypoint {
            return Waypoint.deserialize(bytes);
        }
    }
    export class Route extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            cmt?: string;
            desc?: string;
            src?: string;
            link?: Link[];
            number?: number;
            type?: string;
            extensions?: Map<string, dependency_1.google.protobuf.Any>;
            rtept?: Waypoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5, 9], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("cmt" in data && data.cmt != undefined) {
                    this.cmt = data.cmt;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("src" in data && data.src != undefined) {
                    this.src = data.src;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("number" in data && data.number != undefined) {
                    this.number = data.number;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("extensions" in data && data.extensions != undefined) {
                    this.extensions = data.extensions;
                }
                if ("rtept" in data && data.rtept != undefined) {
                    this.rtept = data.rtept;
                }
            }
            if (!this.extensions)
                this.extensions = new Map();
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get cmt() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set cmt(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get src() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set src(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get link() {
            return pb_1.Message.getRepeatedWrapperField(this, Link, 5) as Link[];
        }
        set link(value: Link[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get number() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set number(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get extensions() {
            return pb_1.Message.getField(this, 8) as any as Map<string, dependency_1.google.protobuf.Any>;
        }
        set extensions(value: Map<string, dependency_1.google.protobuf.Any>) {
            pb_1.Message.setField(this, 8, value as any);
        }
        get rtept() {
            return pb_1.Message.getRepeatedWrapperField(this, Waypoint, 9) as Waypoint[];
        }
        set rtept(value: Waypoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        static fromObject(data: {
            name?: string;
            cmt?: string;
            desc?: string;
            src?: string;
            link?: ReturnType<typeof Link.prototype.toObject>[];
            number?: number;
            type?: string;
            extensions?: {
                [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            };
            rtept?: ReturnType<typeof Waypoint.prototype.toObject>[];
        }): Route {
            const message = new Route({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.cmt != null) {
                message.cmt = data.cmt;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.src != null) {
                message.src = data.src;
            }
            if (data.link != null) {
                message.link = data.link.map(item => Link.fromObject(item));
            }
            if (data.number != null) {
                message.number = data.number;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (typeof data.extensions == "object") {
                message.extensions = new Map(Object.entries(data.extensions).map(([key, value]) => [key, dependency_1.google.protobuf.Any.fromObject(value)]));
            }
            if (data.rtept != null) {
                message.rtept = data.rtept.map(item => Waypoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                cmt?: string;
                desc?: string;
                src?: string;
                link?: ReturnType<typeof Link.prototype.toObject>[];
                number?: number;
                type?: string;
                extensions?: {
                    [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
                };
                rtept?: ReturnType<typeof Waypoint.prototype.toObject>[];
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.cmt != null) {
                data.cmt = this.cmt;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.src != null) {
                data.src = this.src;
            }
            if (this.link != null) {
                data.link = this.link.map((item: Link) => item.toObject());
            }
            if (this.number != null) {
                data.number = this.number;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.extensions != null) {
                data.extensions = (Object.fromEntries)((Array.from)(this.extensions).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.rtept != null) {
                data.rtept = this.rtept.map((item: Waypoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.cmt.length)
                writer.writeString(2, this.cmt);
            if (this.desc.length)
                writer.writeString(3, this.desc);
            if (this.src.length)
                writer.writeString(4, this.src);
            if (this.link.length)
                writer.writeRepeatedMessage(5, this.link, (item: Link) => item.serialize(writer));
            if (this.number != 0)
                writer.writeInt32(6, this.number);
            if (this.type.length)
                writer.writeString(7, this.type);
            for (const [key, value] of this.extensions) {
                writer.writeMessage(8, this.extensions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.rtept.length)
                writer.writeRepeatedMessage(9, this.rtept, (item: Waypoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Route {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Route();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.cmt = reader.readString();
                        break;
                    case 3:
                        message.desc = reader.readString();
                        break;
                    case 4:
                        message.src = reader.readString();
                        break;
                    case 5:
                        reader.readMessage(message.link, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Link.deserialize(reader), Link));
                        break;
                    case 6:
                        message.number = reader.readInt32();
                        break;
                    case 7:
                        message.type = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.extensions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = dependency_1.google.protobuf.Any.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 9:
                        reader.readMessage(message.rtept, () => pb_1.Message.addToRepeatedWrapperField(message, 9, Waypoint.deserialize(reader), Waypoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Route {
            return Route.deserialize(bytes);
        }
    }
    export class Track extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            cmt?: string;
            desc?: string;
            src?: string;
            link?: Link[];
            number?: number;
            type?: string;
            extensions?: Map<string, dependency_1.google.protobuf.Any>;
            trkseg?: TrackSegment[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5, 9], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("cmt" in data && data.cmt != undefined) {
                    this.cmt = data.cmt;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("src" in data && data.src != undefined) {
                    this.src = data.src;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("number" in data && data.number != undefined) {
                    this.number = data.number;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("extensions" in data && data.extensions != undefined) {
                    this.extensions = data.extensions;
                }
                if ("trkseg" in data && data.trkseg != undefined) {
                    this.trkseg = data.trkseg;
                }
            }
            if (!this.extensions)
                this.extensions = new Map();
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get cmt() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set cmt(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get src() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set src(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get link() {
            return pb_1.Message.getRepeatedWrapperField(this, Link, 5) as Link[];
        }
        set link(value: Link[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        get number() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set number(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get extensions() {
            return pb_1.Message.getField(this, 8) as any as Map<string, dependency_1.google.protobuf.Any>;
        }
        set extensions(value: Map<string, dependency_1.google.protobuf.Any>) {
            pb_1.Message.setField(this, 8, value as any);
        }
        get trkseg() {
            return pb_1.Message.getRepeatedWrapperField(this, TrackSegment, 9) as TrackSegment[];
        }
        set trkseg(value: TrackSegment[]) {
            pb_1.Message.setRepeatedWrapperField(this, 9, value);
        }
        static fromObject(data: {
            name?: string;
            cmt?: string;
            desc?: string;
            src?: string;
            link?: ReturnType<typeof Link.prototype.toObject>[];
            number?: number;
            type?: string;
            extensions?: {
                [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            };
            trkseg?: ReturnType<typeof TrackSegment.prototype.toObject>[];
        }): Track {
            const message = new Track({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.cmt != null) {
                message.cmt = data.cmt;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.src != null) {
                message.src = data.src;
            }
            if (data.link != null) {
                message.link = data.link.map(item => Link.fromObject(item));
            }
            if (data.number != null) {
                message.number = data.number;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (typeof data.extensions == "object") {
                message.extensions = new Map(Object.entries(data.extensions).map(([key, value]) => [key, dependency_1.google.protobuf.Any.fromObject(value)]));
            }
            if (data.trkseg != null) {
                message.trkseg = data.trkseg.map(item => TrackSegment.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                cmt?: string;
                desc?: string;
                src?: string;
                link?: ReturnType<typeof Link.prototype.toObject>[];
                number?: number;
                type?: string;
                extensions?: {
                    [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
                };
                trkseg?: ReturnType<typeof TrackSegment.prototype.toObject>[];
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.cmt != null) {
                data.cmt = this.cmt;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.src != null) {
                data.src = this.src;
            }
            if (this.link != null) {
                data.link = this.link.map((item: Link) => item.toObject());
            }
            if (this.number != null) {
                data.number = this.number;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.extensions != null) {
                data.extensions = (Object.fromEntries)((Array.from)(this.extensions).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.trkseg != null) {
                data.trkseg = this.trkseg.map((item: TrackSegment) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.cmt.length)
                writer.writeString(2, this.cmt);
            if (this.desc.length)
                writer.writeString(3, this.desc);
            if (this.src.length)
                writer.writeString(4, this.src);
            if (this.link.length)
                writer.writeRepeatedMessage(5, this.link, (item: Link) => item.serialize(writer));
            if (this.number != 0)
                writer.writeInt32(6, this.number);
            if (this.type.length)
                writer.writeString(7, this.type);
            for (const [key, value] of this.extensions) {
                writer.writeMessage(8, this.extensions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (this.trkseg.length)
                writer.writeRepeatedMessage(9, this.trkseg, (item: TrackSegment) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Track {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Track();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.cmt = reader.readString();
                        break;
                    case 3:
                        message.desc = reader.readString();
                        break;
                    case 4:
                        message.src = reader.readString();
                        break;
                    case 5:
                        reader.readMessage(message.link, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Link.deserialize(reader), Link));
                        break;
                    case 6:
                        message.number = reader.readInt32();
                        break;
                    case 7:
                        message.type = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.extensions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = dependency_1.google.protobuf.Any.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 9:
                        reader.readMessage(message.trkseg, () => pb_1.Message.addToRepeatedWrapperField(message, 9, TrackSegment.deserialize(reader), TrackSegment));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Track {
            return Track.deserialize(bytes);
        }
    }
    export class TrackSegment extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            trkpt?: Waypoint[];
            extensions?: Map<string, dependency_1.google.protobuf.Any>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("trkpt" in data && data.trkpt != undefined) {
                    this.trkpt = data.trkpt;
                }
                if ("extensions" in data && data.extensions != undefined) {
                    this.extensions = data.extensions;
                }
            }
            if (!this.extensions)
                this.extensions = new Map();
        }
        get trkpt() {
            return pb_1.Message.getRepeatedWrapperField(this, Waypoint, 1) as Waypoint[];
        }
        set trkpt(value: Waypoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get extensions() {
            return pb_1.Message.getField(this, 2) as any as Map<string, dependency_1.google.protobuf.Any>;
        }
        set extensions(value: Map<string, dependency_1.google.protobuf.Any>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        static fromObject(data: {
            trkpt?: ReturnType<typeof Waypoint.prototype.toObject>[];
            extensions?: {
                [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            };
        }): TrackSegment {
            const message = new TrackSegment({});
            if (data.trkpt != null) {
                message.trkpt = data.trkpt.map(item => Waypoint.fromObject(item));
            }
            if (typeof data.extensions == "object") {
                message.extensions = new Map(Object.entries(data.extensions).map(([key, value]) => [key, dependency_1.google.protobuf.Any.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                trkpt?: ReturnType<typeof Waypoint.prototype.toObject>[];
                extensions?: {
                    [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
                };
            } = {};
            if (this.trkpt != null) {
                data.trkpt = this.trkpt.map((item: Waypoint) => item.toObject());
            }
            if (this.extensions != null) {
                data.extensions = (Object.fromEntries)((Array.from)(this.extensions).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.trkpt.length)
                writer.writeRepeatedMessage(1, this.trkpt, (item: Waypoint) => item.serialize(writer));
            for (const [key, value] of this.extensions) {
                writer.writeMessage(2, this.extensions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TrackSegment {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TrackSegment();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.trkpt, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Waypoint.deserialize(reader), Waypoint));
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.extensions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = dependency_1.google.protobuf.Any.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TrackSegment {
            return TrackSegment.deserialize(bytes);
        }
    }
    export class Elevation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            max?: number;
            min?: number;
            pos?: number;
            neg?: number;
            avg?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("pos" in data && data.pos != undefined) {
                    this.pos = data.pos;
                }
                if ("neg" in data && data.neg != undefined) {
                    this.neg = data.neg;
                }
                if ("avg" in data && data.avg != undefined) {
                    this.avg = data.avg;
                }
            }
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get pos() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set pos(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get neg() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set neg(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get avg() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set avg(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            max?: number;
            min?: number;
            pos?: number;
            neg?: number;
            avg?: number;
        }): Elevation {
            const message = new Elevation({});
            if (data.max != null) {
                message.max = data.max;
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.pos != null) {
                message.pos = data.pos;
            }
            if (data.neg != null) {
                message.neg = data.neg;
            }
            if (data.avg != null) {
                message.avg = data.avg;
            }
            return message;
        }
        toObject() {
            const data: {
                max?: number;
                min?: number;
                pos?: number;
                neg?: number;
                avg?: number;
            } = {};
            if (this.max != null) {
                data.max = this.max;
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.pos != null) {
                data.pos = this.pos;
            }
            if (this.neg != null) {
                data.neg = this.neg;
            }
            if (this.avg != null) {
                data.avg = this.avg;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.max != 0)
                writer.writeFloat(1, this.max);
            if (this.min != 0)
                writer.writeFloat(2, this.min);
            if (this.pos != 0)
                writer.writeFloat(3, this.pos);
            if (this.neg != 0)
                writer.writeFloat(4, this.neg);
            if (this.avg != 0)
                writer.writeFloat(5, this.avg);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Elevation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Elevation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.max = reader.readFloat();
                        break;
                    case 2:
                        message.min = reader.readFloat();
                        break;
                    case 3:
                        message.pos = reader.readFloat();
                        break;
                    case 4:
                        message.neg = reader.readFloat();
                        break;
                    case 5:
                        message.avg = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Elevation {
            return Elevation.deserialize(bytes);
        }
    }
    export class Distance extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            total?: number;
            cumul?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("total" in data && data.total != undefined) {
                    this.total = data.total;
                }
                if ("cumul" in data && data.cumul != undefined) {
                    this.cumul = data.cumul;
                }
            }
        }
        get total() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set total(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get cumul() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set cumul(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            total?: number;
            cumul?: number;
        }): Distance {
            const message = new Distance({});
            if (data.total != null) {
                message.total = data.total;
            }
            if (data.cumul != null) {
                message.cumul = data.cumul;
            }
            return message;
        }
        toObject() {
            const data: {
                total?: number;
                cumul?: number;
            } = {};
            if (this.total != null) {
                data.total = this.total;
            }
            if (this.cumul != null) {
                data.cumul = this.cumul;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.total != 0)
                writer.writeFloat(1, this.total);
            if (this.cumul != 0)
                writer.writeFloat(2, this.cumul);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Distance {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Distance();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.total = reader.readFloat();
                        break;
                    case 2:
                        message.cumul = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Distance {
            return Distance.deserialize(bytes);
        }
    }
    export class Point extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            lat?: number;
            lon?: number;
            elevation?: number;
            time?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("lat" in data && data.lat != undefined) {
                    this.lat = data.lat;
                }
                if ("lon" in data && data.lon != undefined) {
                    this.lon = data.lon;
                }
                if ("elevation" in data && data.elevation != undefined) {
                    this.elevation = data.elevation;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
            }
        }
        get lat() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set lat(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get lon() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set lon(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get elevation() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set elevation(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            lat?: number;
            lon?: number;
            elevation?: number;
            time?: number;
        }): Point {
            const message = new Point({});
            if (data.lat != null) {
                message.lat = data.lat;
            }
            if (data.lon != null) {
                message.lon = data.lon;
            }
            if (data.elevation != null) {
                message.elevation = data.elevation;
            }
            if (data.time != null) {
                message.time = data.time;
            }
            return message;
        }
        toObject() {
            const data: {
                lat?: number;
                lon?: number;
                elevation?: number;
                time?: number;
            } = {};
            if (this.lat != null) {
                data.lat = this.lat;
            }
            if (this.lon != null) {
                data.lon = this.lon;
            }
            if (this.elevation != null) {
                data.elevation = this.elevation;
            }
            if (this.time != null) {
                data.time = this.time;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.lat != 0)
                writer.writeFloat(1, this.lat);
            if (this.lon != 0)
                writer.writeFloat(2, this.lon);
            if (this.elevation != 0)
                writer.writeFloat(3, this.elevation);
            if (this.time != 0)
                writer.writeInt64(4, this.time);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.lat = reader.readFloat();
                        break;
                    case 2:
                        message.lon = reader.readFloat();
                        break;
                    case 3:
                        message.elevation = reader.readFloat();
                        break;
                    case 4:
                        message.time = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Point {
            return Point.deserialize(bytes);
        }
    }
    export class Metadata extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            desc?: string;
            link?: Link[];
            author?: Author;
            time?: number;
            copyright?: Copyright;
            keywords?: string;
            bounds?: Bounds;
            extensions?: Map<string, dependency_1.google.protobuf.Any>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("author" in data && data.author != undefined) {
                    this.author = data.author;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("copyright" in data && data.copyright != undefined) {
                    this.copyright = data.copyright;
                }
                if ("keywords" in data && data.keywords != undefined) {
                    this.keywords = data.keywords;
                }
                if ("bounds" in data && data.bounds != undefined) {
                    this.bounds = data.bounds;
                }
                if ("extensions" in data && data.extensions != undefined) {
                    this.extensions = data.extensions;
                }
            }
            if (!this.extensions)
                this.extensions = new Map();
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get link() {
            return pb_1.Message.getRepeatedWrapperField(this, Link, 3) as Link[];
        }
        set link(value: Link[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get author() {
            return pb_1.Message.getWrapperField(this, Author, 4) as Author;
        }
        set author(value: Author) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_author() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get copyright() {
            return pb_1.Message.getWrapperField(this, Copyright, 6) as Copyright;
        }
        set copyright(value: Copyright) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_copyright() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get keywords() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set keywords(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get bounds() {
            return pb_1.Message.getWrapperField(this, Bounds, 8) as Bounds;
        }
        set bounds(value: Bounds) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get has_bounds() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get extensions() {
            return pb_1.Message.getField(this, 9) as any as Map<string, dependency_1.google.protobuf.Any>;
        }
        set extensions(value: Map<string, dependency_1.google.protobuf.Any>) {
            pb_1.Message.setField(this, 9, value as any);
        }
        static fromObject(data: {
            name?: string;
            desc?: string;
            link?: ReturnType<typeof Link.prototype.toObject>[];
            author?: ReturnType<typeof Author.prototype.toObject>;
            time?: number;
            copyright?: ReturnType<typeof Copyright.prototype.toObject>;
            keywords?: string;
            bounds?: ReturnType<typeof Bounds.prototype.toObject>;
            extensions?: {
                [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            };
        }): Metadata {
            const message = new Metadata({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.link != null) {
                message.link = data.link.map(item => Link.fromObject(item));
            }
            if (data.author != null) {
                message.author = Author.fromObject(data.author);
            }
            if (data.time != null) {
                message.time = data.time;
            }
            if (data.copyright != null) {
                message.copyright = Copyright.fromObject(data.copyright);
            }
            if (data.keywords != null) {
                message.keywords = data.keywords;
            }
            if (data.bounds != null) {
                message.bounds = Bounds.fromObject(data.bounds);
            }
            if (typeof data.extensions == "object") {
                message.extensions = new Map(Object.entries(data.extensions).map(([key, value]) => [key, dependency_1.google.protobuf.Any.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                desc?: string;
                link?: ReturnType<typeof Link.prototype.toObject>[];
                author?: ReturnType<typeof Author.prototype.toObject>;
                time?: number;
                copyright?: ReturnType<typeof Copyright.prototype.toObject>;
                keywords?: string;
                bounds?: ReturnType<typeof Bounds.prototype.toObject>;
                extensions?: {
                    [key: string]: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
                };
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.link != null) {
                data.link = this.link.map((item: Link) => item.toObject());
            }
            if (this.author != null) {
                data.author = this.author.toObject();
            }
            if (this.time != null) {
                data.time = this.time;
            }
            if (this.copyright != null) {
                data.copyright = this.copyright.toObject();
            }
            if (this.keywords != null) {
                data.keywords = this.keywords;
            }
            if (this.bounds != null) {
                data.bounds = this.bounds.toObject();
            }
            if (this.extensions != null) {
                data.extensions = (Object.fromEntries)((Array.from)(this.extensions).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.desc.length)
                writer.writeString(2, this.desc);
            if (this.link.length)
                writer.writeRepeatedMessage(3, this.link, (item: Link) => item.serialize(writer));
            if (this.has_author)
                writer.writeMessage(4, this.author, () => this.author.serialize(writer));
            if (this.time != 0)
                writer.writeInt64(5, this.time);
            if (this.has_copyright)
                writer.writeMessage(6, this.copyright, () => this.copyright.serialize(writer));
            if (this.keywords.length)
                writer.writeString(7, this.keywords);
            if (this.has_bounds)
                writer.writeMessage(8, this.bounds, () => this.bounds.serialize(writer));
            for (const [key, value] of this.extensions) {
                writer.writeMessage(9, this.extensions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Metadata {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Metadata();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.desc = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.link, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Link.deserialize(reader), Link));
                        break;
                    case 4:
                        reader.readMessage(message.author, () => message.author = Author.deserialize(reader));
                        break;
                    case 5:
                        message.time = reader.readInt64();
                        break;
                    case 6:
                        reader.readMessage(message.copyright, () => message.copyright = Copyright.deserialize(reader));
                        break;
                    case 7:
                        message.keywords = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message.bounds, () => message.bounds = Bounds.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.extensions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = dependency_1.google.protobuf.Any.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Metadata {
            return Metadata.deserialize(bytes);
        }
    }
    export class Copyright extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            year?: number;
            license?: string;
            author?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("year" in data && data.year != undefined) {
                    this.year = data.year;
                }
                if ("license" in data && data.license != undefined) {
                    this.license = data.license;
                }
                if ("author" in data && data.author != undefined) {
                    this.author = data.author;
                }
            }
        }
        get year() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set year(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get license() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set license(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get author() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set author(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            year?: number;
            license?: string;
            author?: string;
        }): Copyright {
            const message = new Copyright({});
            if (data.year != null) {
                message.year = data.year;
            }
            if (data.license != null) {
                message.license = data.license;
            }
            if (data.author != null) {
                message.author = data.author;
            }
            return message;
        }
        toObject() {
            const data: {
                year?: number;
                license?: string;
                author?: string;
            } = {};
            if (this.year != null) {
                data.year = this.year;
            }
            if (this.license != null) {
                data.license = this.license;
            }
            if (this.author != null) {
                data.author = this.author;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.year != 0)
                writer.writeInt32(1, this.year);
            if (this.license.length)
                writer.writeString(2, this.license);
            if (this.author.length)
                writer.writeString(3, this.author);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Copyright {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Copyright();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.year = reader.readInt32();
                        break;
                    case 2:
                        message.license = reader.readString();
                        break;
                    case 3:
                        message.author = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Copyright {
            return Copyright.deserialize(bytes);
        }
    }
    export class Author extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            email?: Email;
            link?: Link;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("email" in data && data.email != undefined) {
                    this.email = data.email;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get email() {
            return pb_1.Message.getWrapperField(this, Email, 2) as Email;
        }
        set email(value: Email) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_email() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get link() {
            return pb_1.Message.getWrapperField(this, Link, 3) as Link;
        }
        set link(value: Link) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_link() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            name?: string;
            email?: ReturnType<typeof Email.prototype.toObject>;
            link?: ReturnType<typeof Link.prototype.toObject>;
        }): Author {
            const message = new Author({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.email != null) {
                message.email = Email.fromObject(data.email);
            }
            if (data.link != null) {
                message.link = Link.fromObject(data.link);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                email?: ReturnType<typeof Email.prototype.toObject>;
                link?: ReturnType<typeof Link.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.email != null) {
                data.email = this.email.toObject();
            }
            if (this.link != null) {
                data.link = this.link.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.has_email)
                writer.writeMessage(2, this.email, () => this.email.serialize(writer));
            if (this.has_link)
                writer.writeMessage(3, this.link, () => this.link.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Author {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Author();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.email, () => message.email = Email.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.link, () => message.link = Link.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Author {
            return Author.deserialize(bytes);
        }
    }
    export class Email extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            domain?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("domain" in data && data.domain != undefined) {
                    this.domain = data.domain;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get domain() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set domain(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            id?: string;
            domain?: string;
        }): Email {
            const message = new Email({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.domain != null) {
                message.domain = data.domain;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                domain?: string;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.domain != null) {
                data.domain = this.domain;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.domain.length)
                writer.writeString(2, this.domain);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Email {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Email();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.domain = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Email {
            return Email.deserialize(bytes);
        }
    }
    export class Bounds extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            minlat?: number;
            minlon?: number;
            maxlat?: number;
            maxlon?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("minlat" in data && data.minlat != undefined) {
                    this.minlat = data.minlat;
                }
                if ("minlon" in data && data.minlon != undefined) {
                    this.minlon = data.minlon;
                }
                if ("maxlat" in data && data.maxlat != undefined) {
                    this.maxlat = data.maxlat;
                }
                if ("maxlon" in data && data.maxlon != undefined) {
                    this.maxlon = data.maxlon;
                }
            }
        }
        get minlat() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set minlat(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get minlon() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set minlon(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get maxlat() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set maxlat(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get maxlon() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set maxlon(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            minlat?: number;
            minlon?: number;
            maxlat?: number;
            maxlon?: number;
        }): Bounds {
            const message = new Bounds({});
            if (data.minlat != null) {
                message.minlat = data.minlat;
            }
            if (data.minlon != null) {
                message.minlon = data.minlon;
            }
            if (data.maxlat != null) {
                message.maxlat = data.maxlat;
            }
            if (data.maxlon != null) {
                message.maxlon = data.maxlon;
            }
            return message;
        }
        toObject() {
            const data: {
                minlat?: number;
                minlon?: number;
                maxlat?: number;
                maxlon?: number;
            } = {};
            if (this.minlat != null) {
                data.minlat = this.minlat;
            }
            if (this.minlon != null) {
                data.minlon = this.minlon;
            }
            if (this.maxlat != null) {
                data.maxlat = this.maxlat;
            }
            if (this.maxlon != null) {
                data.maxlon = this.maxlon;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.minlat != 0)
                writer.writeFloat(1, this.minlat);
            if (this.minlon != 0)
                writer.writeFloat(2, this.minlon);
            if (this.maxlat != 0)
                writer.writeFloat(3, this.maxlat);
            if (this.maxlon != 0)
                writer.writeFloat(4, this.maxlon);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Bounds {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Bounds();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.minlat = reader.readFloat();
                        break;
                    case 2:
                        message.minlon = reader.readFloat();
                        break;
                    case 3:
                        message.maxlat = reader.readFloat();
                        break;
                    case 4:
                        message.maxlon = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Bounds {
            return Bounds.deserialize(bytes);
        }
    }
}
