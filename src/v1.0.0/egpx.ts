/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: src/egpx.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace eGPX {
    export class File extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            version?: number;
            metadata?: Metadata;
            waypoints?: Waypoint[];
            tracks?: Track[];
            routes?: Route[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("metadata" in data && data.metadata != undefined) {
                    this.metadata = data.metadata;
                }
                if ("waypoints" in data && data.waypoints != undefined) {
                    this.waypoints = data.waypoints;
                }
                if ("tracks" in data && data.tracks != undefined) {
                    this.tracks = data.tracks;
                }
                if ("routes" in data && data.routes != undefined) {
                    this.routes = data.routes;
                }
            }
        }
        get version() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set version(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get metadata() {
            return pb_1.Message.getWrapperField(this, Metadata, 2) as Metadata;
        }
        set metadata(value: Metadata) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_metadata() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get waypoints() {
            return pb_1.Message.getRepeatedWrapperField(this, Waypoint, 3) as Waypoint[];
        }
        set waypoints(value: Waypoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get tracks() {
            return pb_1.Message.getRepeatedWrapperField(this, Track, 4) as Track[];
        }
        set tracks(value: Track[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get routes() {
            return pb_1.Message.getRepeatedWrapperField(this, Route, 5) as Route[];
        }
        set routes(value: Route[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        static fromObject(data: {
            version?: number;
            metadata?: ReturnType<typeof Metadata.prototype.toObject>;
            waypoints?: ReturnType<typeof Waypoint.prototype.toObject>[];
            tracks?: ReturnType<typeof Track.prototype.toObject>[];
            routes?: ReturnType<typeof Route.prototype.toObject>[];
        }): File {
            const message = new File({});
            if (data.version != null) {
                message.version = data.version;
            }
            if (data.metadata != null) {
                message.metadata = Metadata.fromObject(data.metadata);
            }
            if (data.waypoints != null) {
                message.waypoints = data.waypoints.map(item => Waypoint.fromObject(item));
            }
            if (data.tracks != null) {
                message.tracks = data.tracks.map(item => Track.fromObject(item));
            }
            if (data.routes != null) {
                message.routes = data.routes.map(item => Route.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                version?: number;
                metadata?: ReturnType<typeof Metadata.prototype.toObject>;
                waypoints?: ReturnType<typeof Waypoint.prototype.toObject>[];
                tracks?: ReturnType<typeof Track.prototype.toObject>[];
                routes?: ReturnType<typeof Route.prototype.toObject>[];
            } = {};
            if (this.version != null) {
                data.version = this.version;
            }
            if (this.metadata != null) {
                data.metadata = this.metadata.toObject();
            }
            if (this.waypoints != null) {
                data.waypoints = this.waypoints.map((item: Waypoint) => item.toObject());
            }
            if (this.tracks != null) {
                data.tracks = this.tracks.map((item: Track) => item.toObject());
            }
            if (this.routes != null) {
                data.routes = this.routes.map((item: Route) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.version != 0)
                writer.writeInt32(1, this.version);
            if (this.has_metadata)
                writer.writeMessage(2, this.metadata, () => this.metadata.serialize(writer));
            if (this.waypoints.length)
                writer.writeRepeatedMessage(3, this.waypoints, (item: Waypoint) => item.serialize(writer));
            if (this.tracks.length)
                writer.writeRepeatedMessage(4, this.tracks, (item: Track) => item.serialize(writer));
            if (this.routes.length)
                writer.writeRepeatedMessage(5, this.routes, (item: Route) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): File {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new File();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.version = reader.readInt32();
                        break;
                    case 2:
                        reader.readMessage(message.metadata, () => message.metadata = Metadata.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.waypoints, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Waypoint.deserialize(reader), Waypoint));
                        break;
                    case 4:
                        reader.readMessage(message.tracks, () => pb_1.Message.addToRepeatedWrapperField(message, 4, Track.deserialize(reader), Track));
                        break;
                    case 5:
                        reader.readMessage(message.routes, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Route.deserialize(reader), Route));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): File {
            return File.deserialize(bytes);
        }
    }
    export class Route extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            comment?: string;
            desc?: string;
            src?: string;
            id?: string;
            link?: string;
            type?: string;
            points?: Point[];
            distance?: Distance;
            elevation?: Elevation;
            slopes?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8, 11], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("comment" in data && data.comment != undefined) {
                    this.comment = data.comment;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("src" in data && data.src != undefined) {
                    this.src = data.src;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("points" in data && data.points != undefined) {
                    this.points = data.points;
                }
                if ("distance" in data && data.distance != undefined) {
                    this.distance = data.distance;
                }
                if ("elevation" in data && data.elevation != undefined) {
                    this.elevation = data.elevation;
                }
                if ("slopes" in data && data.slopes != undefined) {
                    this.slopes = data.slopes;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get comment() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set comment(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get src() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set src(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get link() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set link(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get points() {
            return pb_1.Message.getRepeatedWrapperField(this, Point, 8) as Point[];
        }
        set points(value: Point[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get distance() {
            return pb_1.Message.getWrapperField(this, Distance, 9) as Distance;
        }
        set distance(value: Distance) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_distance() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get elevation() {
            return pb_1.Message.getWrapperField(this, Elevation, 10) as Elevation;
        }
        set elevation(value: Elevation) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        get has_elevation() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get slopes() {
            return pb_1.Message.getFieldWithDefault(this, 11, []) as number[];
        }
        set slopes(value: number[]) {
            pb_1.Message.setField(this, 11, value);
        }
        static fromObject(data: {
            name?: string;
            comment?: string;
            desc?: string;
            src?: string;
            id?: string;
            link?: string;
            type?: string;
            points?: ReturnType<typeof Point.prototype.toObject>[];
            distance?: ReturnType<typeof Distance.prototype.toObject>;
            elevation?: ReturnType<typeof Elevation.prototype.toObject>;
            slopes?: number[];
        }): Route {
            const message = new Route({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.comment != null) {
                message.comment = data.comment;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.src != null) {
                message.src = data.src;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.link != null) {
                message.link = data.link;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.points != null) {
                message.points = data.points.map(item => Point.fromObject(item));
            }
            if (data.distance != null) {
                message.distance = Distance.fromObject(data.distance);
            }
            if (data.elevation != null) {
                message.elevation = Elevation.fromObject(data.elevation);
            }
            if (data.slopes != null) {
                message.slopes = data.slopes;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                comment?: string;
                desc?: string;
                src?: string;
                id?: string;
                link?: string;
                type?: string;
                points?: ReturnType<typeof Point.prototype.toObject>[];
                distance?: ReturnType<typeof Distance.prototype.toObject>;
                elevation?: ReturnType<typeof Elevation.prototype.toObject>;
                slopes?: number[];
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.comment != null) {
                data.comment = this.comment;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.src != null) {
                data.src = this.src;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.link != null) {
                data.link = this.link;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.points != null) {
                data.points = this.points.map((item: Point) => item.toObject());
            }
            if (this.distance != null) {
                data.distance = this.distance.toObject();
            }
            if (this.elevation != null) {
                data.elevation = this.elevation.toObject();
            }
            if (this.slopes != null) {
                data.slopes = this.slopes;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.comment.length)
                writer.writeString(2, this.comment);
            if (this.desc.length)
                writer.writeString(3, this.desc);
            if (this.src.length)
                writer.writeString(4, this.src);
            if (this.id.length)
                writer.writeString(5, this.id);
            if (this.link.length)
                writer.writeString(6, this.link);
            if (this.type.length)
                writer.writeString(7, this.type);
            if (this.points.length)
                writer.writeRepeatedMessage(8, this.points, (item: Point) => item.serialize(writer));
            if (this.has_distance)
                writer.writeMessage(9, this.distance, () => this.distance.serialize(writer));
            if (this.has_elevation)
                writer.writeMessage(10, this.elevation, () => this.elevation.serialize(writer));
            if (this.slopes.length)
                writer.writePackedFloat(11, this.slopes);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Route {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Route();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.comment = reader.readString();
                        break;
                    case 3:
                        message.desc = reader.readString();
                        break;
                    case 4:
                        message.src = reader.readString();
                        break;
                    case 5:
                        message.id = reader.readString();
                        break;
                    case 6:
                        message.link = reader.readString();
                        break;
                    case 7:
                        message.type = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message.points, () => pb_1.Message.addToRepeatedWrapperField(message, 8, Point.deserialize(reader), Point));
                        break;
                    case 9:
                        reader.readMessage(message.distance, () => message.distance = Distance.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.elevation, () => message.elevation = Elevation.deserialize(reader));
                        break;
                    case 11:
                        message.slopes = reader.readPackedFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Route {
            return Route.deserialize(bytes);
        }
    }
    export class Track extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            comment?: string;
            desc?: string;
            src?: string;
            id?: string;
            link?: string;
            type?: string;
            points?: Point[];
            distance?: Distance;
            elevation?: Elevation;
            slopes?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [8, 11], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("comment" in data && data.comment != undefined) {
                    this.comment = data.comment;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("src" in data && data.src != undefined) {
                    this.src = data.src;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("points" in data && data.points != undefined) {
                    this.points = data.points;
                }
                if ("distance" in data && data.distance != undefined) {
                    this.distance = data.distance;
                }
                if ("elevation" in data && data.elevation != undefined) {
                    this.elevation = data.elevation;
                }
                if ("slopes" in data && data.slopes != undefined) {
                    this.slopes = data.slopes;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get comment() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set comment(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get src() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set src(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get link() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set link(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 7, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get points() {
            return pb_1.Message.getRepeatedWrapperField(this, Point, 8) as Point[];
        }
        set points(value: Point[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        get distance() {
            return pb_1.Message.getWrapperField(this, Distance, 9) as Distance;
        }
        set distance(value: Distance) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_distance() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get elevation() {
            return pb_1.Message.getWrapperField(this, Elevation, 10) as Elevation;
        }
        set elevation(value: Elevation) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        get has_elevation() {
            return pb_1.Message.getField(this, 10) != null;
        }
        get slopes() {
            return pb_1.Message.getFieldWithDefault(this, 11, []) as number[];
        }
        set slopes(value: number[]) {
            pb_1.Message.setField(this, 11, value);
        }
        static fromObject(data: {
            name?: string;
            comment?: string;
            desc?: string;
            src?: string;
            id?: string;
            link?: string;
            type?: string;
            points?: ReturnType<typeof Point.prototype.toObject>[];
            distance?: ReturnType<typeof Distance.prototype.toObject>;
            elevation?: ReturnType<typeof Elevation.prototype.toObject>;
            slopes?: number[];
        }): Track {
            const message = new Track({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.comment != null) {
                message.comment = data.comment;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.src != null) {
                message.src = data.src;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.link != null) {
                message.link = data.link;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.points != null) {
                message.points = data.points.map(item => Point.fromObject(item));
            }
            if (data.distance != null) {
                message.distance = Distance.fromObject(data.distance);
            }
            if (data.elevation != null) {
                message.elevation = Elevation.fromObject(data.elevation);
            }
            if (data.slopes != null) {
                message.slopes = data.slopes;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                comment?: string;
                desc?: string;
                src?: string;
                id?: string;
                link?: string;
                type?: string;
                points?: ReturnType<typeof Point.prototype.toObject>[];
                distance?: ReturnType<typeof Distance.prototype.toObject>;
                elevation?: ReturnType<typeof Elevation.prototype.toObject>;
                slopes?: number[];
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.comment != null) {
                data.comment = this.comment;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.src != null) {
                data.src = this.src;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.link != null) {
                data.link = this.link;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.points != null) {
                data.points = this.points.map((item: Point) => item.toObject());
            }
            if (this.distance != null) {
                data.distance = this.distance.toObject();
            }
            if (this.elevation != null) {
                data.elevation = this.elevation.toObject();
            }
            if (this.slopes != null) {
                data.slopes = this.slopes;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.comment.length)
                writer.writeString(2, this.comment);
            if (this.desc.length)
                writer.writeString(3, this.desc);
            if (this.src.length)
                writer.writeString(4, this.src);
            if (this.id.length)
                writer.writeString(5, this.id);
            if (this.link.length)
                writer.writeString(6, this.link);
            if (this.type.length)
                writer.writeString(7, this.type);
            if (this.points.length)
                writer.writeRepeatedMessage(8, this.points, (item: Point) => item.serialize(writer));
            if (this.has_distance)
                writer.writeMessage(9, this.distance, () => this.distance.serialize(writer));
            if (this.has_elevation)
                writer.writeMessage(10, this.elevation, () => this.elevation.serialize(writer));
            if (this.slopes.length)
                writer.writePackedFloat(11, this.slopes);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Track {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Track();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.comment = reader.readString();
                        break;
                    case 3:
                        message.desc = reader.readString();
                        break;
                    case 4:
                        message.src = reader.readString();
                        break;
                    case 5:
                        message.id = reader.readString();
                        break;
                    case 6:
                        message.link = reader.readString();
                        break;
                    case 7:
                        message.type = reader.readString();
                        break;
                    case 8:
                        reader.readMessage(message.points, () => pb_1.Message.addToRepeatedWrapperField(message, 8, Point.deserialize(reader), Point));
                        break;
                    case 9:
                        reader.readMessage(message.distance, () => message.distance = Distance.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.elevation, () => message.elevation = Elevation.deserialize(reader));
                        break;
                    case 11:
                        message.slopes = reader.readPackedFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Track {
            return Track.deserialize(bytes);
        }
    }
    export class Elevation extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            max?: number;
            min?: number;
            pos?: number;
            neg?: number;
            avg?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("max" in data && data.max != undefined) {
                    this.max = data.max;
                }
                if ("min" in data && data.min != undefined) {
                    this.min = data.min;
                }
                if ("pos" in data && data.pos != undefined) {
                    this.pos = data.pos;
                }
                if ("neg" in data && data.neg != undefined) {
                    this.neg = data.neg;
                }
                if ("avg" in data && data.avg != undefined) {
                    this.avg = data.avg;
                }
            }
        }
        get max() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set max(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get min() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set min(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get pos() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set pos(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get neg() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set neg(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get avg() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set avg(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            max?: number;
            min?: number;
            pos?: number;
            neg?: number;
            avg?: number;
        }): Elevation {
            const message = new Elevation({});
            if (data.max != null) {
                message.max = data.max;
            }
            if (data.min != null) {
                message.min = data.min;
            }
            if (data.pos != null) {
                message.pos = data.pos;
            }
            if (data.neg != null) {
                message.neg = data.neg;
            }
            if (data.avg != null) {
                message.avg = data.avg;
            }
            return message;
        }
        toObject() {
            const data: {
                max?: number;
                min?: number;
                pos?: number;
                neg?: number;
                avg?: number;
            } = {};
            if (this.max != null) {
                data.max = this.max;
            }
            if (this.min != null) {
                data.min = this.min;
            }
            if (this.pos != null) {
                data.pos = this.pos;
            }
            if (this.neg != null) {
                data.neg = this.neg;
            }
            if (this.avg != null) {
                data.avg = this.avg;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.max != 0)
                writer.writeFloat(1, this.max);
            if (this.min != 0)
                writer.writeFloat(2, this.min);
            if (this.pos != 0)
                writer.writeFloat(3, this.pos);
            if (this.neg != 0)
                writer.writeFloat(4, this.neg);
            if (this.avg != 0)
                writer.writeFloat(5, this.avg);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Elevation {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Elevation();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.max = reader.readFloat();
                        break;
                    case 2:
                        message.min = reader.readFloat();
                        break;
                    case 3:
                        message.pos = reader.readFloat();
                        break;
                    case 4:
                        message.neg = reader.readFloat();
                        break;
                    case 5:
                        message.avg = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Elevation {
            return Elevation.deserialize(bytes);
        }
    }
    export class Distance extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            total?: number;
            cumul?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("total" in data && data.total != undefined) {
                    this.total = data.total;
                }
                if ("cumul" in data && data.cumul != undefined) {
                    this.cumul = data.cumul;
                }
            }
        }
        get total() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set total(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get cumul() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set cumul(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            total?: number;
            cumul?: number;
        }): Distance {
            const message = new Distance({});
            if (data.total != null) {
                message.total = data.total;
            }
            if (data.cumul != null) {
                message.cumul = data.cumul;
            }
            return message;
        }
        toObject() {
            const data: {
                total?: number;
                cumul?: number;
            } = {};
            if (this.total != null) {
                data.total = this.total;
            }
            if (this.cumul != null) {
                data.cumul = this.cumul;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.total != 0)
                writer.writeFloat(1, this.total);
            if (this.cumul != 0)
                writer.writeFloat(2, this.cumul);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Distance {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Distance();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.total = reader.readFloat();
                        break;
                    case 2:
                        message.cumul = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Distance {
            return Distance.deserialize(bytes);
        }
    }
    export class Point extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            lat?: number;
            lon?: number;
            elevation?: number;
            time?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("lat" in data && data.lat != undefined) {
                    this.lat = data.lat;
                }
                if ("lon" in data && data.lon != undefined) {
                    this.lon = data.lon;
                }
                if ("elevation" in data && data.elevation != undefined) {
                    this.elevation = data.elevation;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
            }
        }
        get lat() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set lat(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get lon() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set lon(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get elevation() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set elevation(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            lat?: number;
            lon?: number;
            elevation?: number;
            time?: number;
        }): Point {
            const message = new Point({});
            if (data.lat != null) {
                message.lat = data.lat;
            }
            if (data.lon != null) {
                message.lon = data.lon;
            }
            if (data.elevation != null) {
                message.elevation = data.elevation;
            }
            if (data.time != null) {
                message.time = data.time;
            }
            return message;
        }
        toObject() {
            const data: {
                lat?: number;
                lon?: number;
                elevation?: number;
                time?: number;
            } = {};
            if (this.lat != null) {
                data.lat = this.lat;
            }
            if (this.lon != null) {
                data.lon = this.lon;
            }
            if (this.elevation != null) {
                data.elevation = this.elevation;
            }
            if (this.time != null) {
                data.time = this.time;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.lat != 0)
                writer.writeFloat(1, this.lat);
            if (this.lon != 0)
                writer.writeFloat(2, this.lon);
            if (this.elevation != 0)
                writer.writeFloat(3, this.elevation);
            if (this.time != 0)
                writer.writeInt64(4, this.time);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.lat = reader.readFloat();
                        break;
                    case 2:
                        message.lon = reader.readFloat();
                        break;
                    case 3:
                        message.elevation = reader.readFloat();
                        break;
                    case 4:
                        message.time = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Point {
            return Point.deserialize(bytes);
        }
    }
    export class Waypoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            comment?: string;
            desc?: string;
            lat?: number;
            lon?: number;
            elevation?: number;
            time?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("comment" in data && data.comment != undefined) {
                    this.comment = data.comment;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("lat" in data && data.lat != undefined) {
                    this.lat = data.lat;
                }
                if ("lon" in data && data.lon != undefined) {
                    this.lon = data.lon;
                }
                if ("elevation" in data && data.elevation != undefined) {
                    this.elevation = data.elevation;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get comment() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set comment(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get lat() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set lat(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get lon() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set lon(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get elevation() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set elevation(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            name?: string;
            comment?: string;
            desc?: string;
            lat?: number;
            lon?: number;
            elevation?: number;
            time?: number;
        }): Waypoint {
            const message = new Waypoint({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.comment != null) {
                message.comment = data.comment;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.lat != null) {
                message.lat = data.lat;
            }
            if (data.lon != null) {
                message.lon = data.lon;
            }
            if (data.elevation != null) {
                message.elevation = data.elevation;
            }
            if (data.time != null) {
                message.time = data.time;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                comment?: string;
                desc?: string;
                lat?: number;
                lon?: number;
                elevation?: number;
                time?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.comment != null) {
                data.comment = this.comment;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.lat != null) {
                data.lat = this.lat;
            }
            if (this.lon != null) {
                data.lon = this.lon;
            }
            if (this.elevation != null) {
                data.elevation = this.elevation;
            }
            if (this.time != null) {
                data.time = this.time;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.comment.length)
                writer.writeString(2, this.comment);
            if (this.desc.length)
                writer.writeString(3, this.desc);
            if (this.lat != 0)
                writer.writeFloat(4, this.lat);
            if (this.lon != 0)
                writer.writeFloat(5, this.lon);
            if (this.elevation != 0)
                writer.writeInt32(6, this.elevation);
            if (this.time != 0)
                writer.writeInt64(7, this.time);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Waypoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Waypoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.comment = reader.readString();
                        break;
                    case 3:
                        message.desc = reader.readString();
                        break;
                    case 4:
                        message.lat = reader.readFloat();
                        break;
                    case 5:
                        message.lon = reader.readFloat();
                        break;
                    case 6:
                        message.elevation = reader.readInt32();
                        break;
                    case 7:
                        message.time = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Waypoint {
            return Waypoint.deserialize(bytes);
        }
    }
    export class Metadata extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            desc?: string;
            link?: string;
            author?: Author;
            time?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("desc" in data && data.desc != undefined) {
                    this.desc = data.desc;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
                if ("author" in data && data.author != undefined) {
                    this.author = data.author;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get desc() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set desc(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get link() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set link(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get author() {
            return pb_1.Message.getWrapperField(this, Author, 4) as Author;
        }
        set author(value: Author) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_author() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get time() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set time(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            name?: string;
            desc?: string;
            link?: string;
            author?: ReturnType<typeof Author.prototype.toObject>;
            time?: number;
        }): Metadata {
            const message = new Metadata({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.desc != null) {
                message.desc = data.desc;
            }
            if (data.link != null) {
                message.link = data.link;
            }
            if (data.author != null) {
                message.author = Author.fromObject(data.author);
            }
            if (data.time != null) {
                message.time = data.time;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                desc?: string;
                link?: string;
                author?: ReturnType<typeof Author.prototype.toObject>;
                time?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.desc != null) {
                data.desc = this.desc;
            }
            if (this.link != null) {
                data.link = this.link;
            }
            if (this.author != null) {
                data.author = this.author.toObject();
            }
            if (this.time != null) {
                data.time = this.time;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.desc.length)
                writer.writeString(2, this.desc);
            if (this.link.length)
                writer.writeString(3, this.link);
            if (this.has_author)
                writer.writeMessage(4, this.author, () => this.author.serialize(writer));
            if (this.time != 0)
                writer.writeInt64(5, this.time);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Metadata {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Metadata();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.desc = reader.readString();
                        break;
                    case 3:
                        message.link = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.author, () => message.author = Author.deserialize(reader));
                        break;
                    case 5:
                        message.time = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Metadata {
            return Metadata.deserialize(bytes);
        }
    }
    export class Author extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            email?: string;
            link?: Link;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("email" in data && data.email != undefined) {
                    this.email = data.email;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get email() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set email(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get link() {
            return pb_1.Message.getWrapperField(this, Link, 3) as Link;
        }
        set link(value: Link) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_link() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            name?: string;
            email?: string;
            link?: ReturnType<typeof Link.prototype.toObject>;
        }): Author {
            const message = new Author({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.email != null) {
                message.email = data.email;
            }
            if (data.link != null) {
                message.link = Link.fromObject(data.link);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                email?: string;
                link?: ReturnType<typeof Link.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.email != null) {
                data.email = this.email;
            }
            if (this.link != null) {
                data.link = this.link.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.email.length)
                writer.writeString(2, this.email);
            if (this.has_link)
                writer.writeMessage(3, this.link, () => this.link.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Author {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Author();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.email = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.link, () => message.link = Link.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Author {
            return Author.deserialize(bytes);
        }
    }
    export class Link extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            href?: string;
            text?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("href" in data && data.href != undefined) {
                    this.href = data.href;
                }
                if ("text" in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get href() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set href(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set text(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            href?: string;
            text?: string;
        }): Link {
            const message = new Link({});
            if (data.href != null) {
                message.href = data.href;
            }
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                href?: string;
                text?: string;
            } = {};
            if (this.href != null) {
                data.href = this.href;
            }
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.href.length)
                writer.writeString(1, this.href);
            if (this.text.length)
                writer.writeString(2, this.text);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Link {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Link();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.href = reader.readString();
                        break;
                    case 2:
                        message.text = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Link {
            return Link.deserialize(bytes);
        }
    }
}
